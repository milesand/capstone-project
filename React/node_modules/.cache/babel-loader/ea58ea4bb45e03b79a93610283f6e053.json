{"ast":null,"code":"var _this = this;\n\n/* global chrome location ReadableStream define MessageChannel TransformStream */\n;\n\n(function (name, definition) {\n  typeof module !== 'undefined' ? module.exports = definition() : typeof define === 'function' && typeof define.amd === 'object' ? define(definition) : _this[name] = definition();\n})('streamSaver', function () {\n  'use strict';\n\n  var mitmTransporter = null;\n  var supportsTransferable = false;\n\n  var test = function test(fn) {\n    try {\n      fn();\n    } catch (e) {}\n  };\n\n  var ponyfill = window.WebStreamsPolyfill || {};\n  var isSecureContext = window.isSecureContext; // TODO: Must come up with a real detection test (#69)\n\n  var useBlobFallback = /constructor/i.test(window.HTMLElement) || !!window.safari || !!window.WebKitPoint;\n  var downloadStrategy = isSecureContext || 'MozAppearance' in document.documentElement.style ? 'iframe' : 'navigate';\n  var streamSaver = {\n    createWriteStream: createWriteStream,\n    WritableStream: window.WritableStream || ponyfill.WritableStream,\n    supported: true,\n    version: {\n      full: '2.0.0',\n      major: 2,\n      minor: 0,\n      dot: 0\n    },\n    mitm: 'https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0'\n    /**\n     * create a hidden iframe and append it to the DOM (body)\n     *\n     * @param  {string} src page to load\n     * @return {HTMLIFrameElement} page to load\n     */\n\n  };\n\n  function makeIframe(src) {\n    if (!src) throw new Error('meh');\n    var iframe = document.createElement('iframe');\n    iframe.hidden = true;\n    iframe.src = src;\n    iframe.loaded = false;\n    iframe.name = 'iframe';\n    iframe.isIframe = true;\n\n    iframe.postMessage = function () {\n      var _iframe$contentWindow;\n\n      return (_iframe$contentWindow = iframe.contentWindow).postMessage.apply(_iframe$contentWindow, arguments);\n    };\n\n    iframe.addEventListener('load', function () {\n      iframe.loaded = true;\n    }, {\n      once: true\n    });\n    document.body.appendChild(iframe);\n    return iframe;\n  }\n  /**\n   * create a popup that simulates the basic things\n   * of what a iframe can do\n   *\n   * @param  {string} src page to load\n   * @return {object}     iframe like object\n   */\n\n\n  function makePopup(src) {\n    var options = 'width=200,height=100';\n    var delegate = document.createDocumentFragment();\n    var popup = {\n      frame: window.open(src, 'popup', options),\n      loaded: false,\n      isIframe: false,\n      isPopup: true,\n      remove: function remove() {\n        popup.frame.close();\n      },\n      addEventListener: function addEventListener() {\n        delegate.addEventListener.apply(delegate, arguments);\n      },\n      dispatchEvent: function dispatchEvent() {\n        delegate.dispatchEvent.apply(delegate, arguments);\n      },\n      removeEventListener: function removeEventListener() {\n        delegate.removeEventListener.apply(delegate, arguments);\n      },\n      postMessage: function postMessage() {\n        var _popup$frame;\n\n        (_popup$frame = popup.frame).postMessage.apply(_popup$frame, arguments);\n      }\n    };\n\n    var onReady = function onReady(evt) {\n      if (evt.source === popup.frame) {\n        popup.loaded = true;\n        window.removeEventListener('message', onReady);\n        popup.dispatchEvent(new Event('load'));\n      }\n    };\n\n    window.addEventListener('message', onReady);\n    return popup;\n  }\n\n  try {\n    // We can't look for service worker since it may still work on http\n    new Response(new ReadableStream());\n\n    if (isSecureContext && !('serviceWorker' in navigator)) {\n      useBlobFallback = true;\n    }\n  } catch (err) {\n    useBlobFallback = true;\n  }\n\n  test(function () {\n    // Transfariable stream was first enabled in chrome v73 behind a flag\n    var _ref = new TransformStream(),\n        readable = _ref.readable;\n\n    var mc = new MessageChannel();\n    mc.port1.postMessage(readable, [readable]);\n    mc.port1.close();\n    mc.port2.close();\n    supportsTransferable = true; // Freeze TransformStream object (can only work with native)\n\n    Object.defineProperty(streamSaver, 'TransformStream', {\n      configurable: false,\n      writable: false,\n      value: TransformStream\n    });\n  });\n\n  function loadTransporter() {\n    if (!mitmTransporter) {\n      mitmTransporter = isSecureContext ? makeIframe(streamSaver.mitm) : makePopup(streamSaver.mitm);\n    }\n  }\n  /**\n   * @param  {string} filename filename that should be used\n   * @param  {object} options  [description]\n   * @param  {number} size     depricated\n   * @return {WritableStream}\n   */\n\n\n  function createWriteStream(filename, options, size) {\n    var opts = {\n      size: null,\n      pathname: null,\n      writableStrategy: undefined,\n      readableStrategy: undefined\n    };\n    var bytesWritten = 0; // by StreamSaver.js (not the service worker)\n\n    var downloadUrl = null;\n    var channel = null;\n    var ts = null; // normalize arguments\n\n    if (Number.isFinite(options)) {\n      var _ref2 = [options, size];\n      size = _ref2[0];\n      options = _ref2[1];\n      console.warn('[StreamSaver] Depricated pass an object as 2nd argument when creating a write stream');\n      opts.size = size;\n      opts.writableStrategy = options;\n    } else if (options && options.highWaterMark) {\n      console.warn('[StreamSaver] Depricated pass an object as 2nd argument when creating a write stream');\n      opts.size = size;\n      opts.writableStrategy = options;\n    } else {\n      opts = options || {};\n    }\n\n    if (!useBlobFallback) {\n      loadTransporter();\n      channel = new MessageChannel(); // Make filename RFC5987 compatible\n\n      filename = encodeURIComponent(filename.replace(/\\//g, ':')).replace(/['()]/g, escape).replace(/\\*/g, '%2A');\n      var response = {\n        transferringReadable: supportsTransferable,\n        pathname: opts.pathname || Math.random().toString().slice(-6) + '/' + filename,\n        headers: {\n          'Content-Type': 'application/octet-stream; charset=utf-8',\n          'Content-Disposition': \"attachment; filename*=UTF-8''\" + filename\n        }\n      };\n\n      if (opts.size) {\n        response.headers['Content-Length'] = opts.size;\n      }\n\n      var args = [response, '*', [channel.port2]];\n\n      if (supportsTransferable) {\n        var transformer = downloadStrategy === 'iframe' ? undefined : {\n          // This transformer & flush method is only used by insecure context.\n          transform: function transform(chunk, controller) {\n            bytesWritten += chunk.length;\n            controller.enqueue(chunk);\n\n            if (downloadUrl) {\n              location.href = downloadUrl;\n              downloadUrl = null;\n            }\n          },\n          flush: function flush() {\n            if (downloadUrl) {\n              location.href = downloadUrl;\n            }\n          }\n        };\n        ts = new streamSaver.TransformStream(transformer, opts.writableStrategy, opts.readableStrategy);\n        var readableStream = ts.readable;\n        channel.port1.postMessage({\n          readableStream: readableStream\n        }, [readableStream]);\n      }\n\n      channel.port1.onmessage = function (evt) {\n        // Service worker sent us a link that we should open.\n        if (evt.data.download) {\n          // Special treatment for popup...\n          if (downloadStrategy === 'navigate') {\n            mitmTransporter.remove();\n            mitmTransporter = null;\n\n            if (bytesWritten) {\n              location.href = evt.data.download;\n            } else {\n              downloadUrl = evt.data.download;\n            }\n          } else {\n            if (mitmTransporter.isPopup) {\n              mitmTransporter.remove(); // Special case for firefox, they can keep sw alive with fetch\n\n              if (downloadStrategy === 'iframe') {\n                makeIframe(streamSaver.mitm);\n              }\n            } // We never remove this iframes b/c it can interrupt saving\n\n\n            makeIframe(evt.data.download);\n          }\n        }\n      };\n\n      if (mitmTransporter.loaded) {\n        var _mitmTransporter;\n\n        (_mitmTransporter = mitmTransporter).postMessage.apply(_mitmTransporter, args);\n      } else {\n        mitmTransporter.addEventListener('load', function () {\n          var _mitmTransporter2;\n\n          (_mitmTransporter2 = mitmTransporter).postMessage.apply(_mitmTransporter2, args);\n        }, {\n          once: true\n        });\n      }\n    }\n\n    var chunks = [];\n    return !useBlobFallback && ts && ts.writable || new streamSaver.WritableStream({\n      write: function write(chunk) {\n        if (useBlobFallback) {\n          // Safari... The new IE6\n          // https://github.com/jimmywarting/StreamSaver.js/issues/69\n          //\n          // even doe it has everything it fails to download anything\n          // that comes from the service worker..!\n          chunks.push(chunk);\n          return;\n        } // is called when a new chunk of data is ready to be written\n        // to the underlying sink. It can return a promise to signal\n        // success or failure of the write operation. The stream\n        // implementation guarantees that this method will be called\n        // only after previous writes have succeeded, and never after\n        // close or abort is called.\n        // TODO: Kind of important that service worker respond back when\n        // it has been written. Otherwise we can't handle backpressure\n        // EDIT: Transfarable streams solvs this...\n\n\n        channel.port1.postMessage(chunk);\n        bytesWritten += chunk.length;\n\n        if (downloadUrl) {\n          location.href = downloadUrl;\n          downloadUrl = null;\n        }\n      },\n      close: function close() {\n        if (useBlobFallback) {\n          var blob = new Blob(chunks, {\n            type: 'application/octet-stream; charset=utf-8'\n          });\n          var link = document.createElement('a');\n          link.href = URL.createObjectURL(blob);\n          link.download = filename;\n          link.click();\n        } else {\n          channel.port1.postMessage('end');\n        }\n      },\n      abort: function abort() {\n        chunks = [];\n        channel.port1.postMessage('abort');\n        channel.port1.onmessage = null;\n        channel.port1.close();\n        channel.port2.close();\n        channel = null;\n      }\n    }, opts.writableStrategy);\n  }\n\n  return streamSaver;\n});","map":null,"metadata":{},"sourceType":"script"}
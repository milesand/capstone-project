# Capstone-project

실행방법
==================
1. manage.py가 위치한 폴더(`./app`)에 `googleAccount.txt` 추가 (카톡방에 올려드릴게요)
2. docker-compose.yml이 위치한 폴더(`.`)에서 `./udco up`
3. 아래에 적혀있는 URL 사용방법대로 사용하면 됩니다.

5/3 수정사항
------------------
1. 메일 인증을 받지 않은 사용자가 로그인 했을 때, 메일 인증을 받게 하는 안내 페이지를 제작했습니다. 여기서 인증 메일을 다시 전송받을 수 있습니다.
2. JWT 토큰 저장 방식을 local storage에서 httponly cookie로 변경했습니다.
   - 보안상 httponly cookie로 저장하는 것이 더 안전하기 때문입니다. local storage에 저장하면 xss공격에 취약해지고, httponly cookie에 저장하면 xss 공격은 막을 수 있지만 csrf 공격에 취약해집니다. 하지만 csrf 공격이 상대적으로 더 막기 쉬우므로, 상용 서비스에서는 일반적으로 httponly cookie에 JWT 토큰을 저장합니다. 
   
5/4 수정사항
------------------
1. 로그인한 사용자가 새로고침 했을 때, 로그인 화면으로 이동하는 현상을 수정했습니다.
2. 로그인 확인 페이지를 /로 수정했습니다. 해당 페이지에서 로그인한 사용자의 아이디를 확인할 수 있습니다.

5/5 수정사항
------------------
1. 회원가입 폼의 각 입력 필드의 입력값을 검증하고, 유효하지 않을 경우 입력 필드 아래에 조건을 표시하도록 구현했습니다
.
![signup](https://user-images.githubusercontent.com/49271247/81073996-5facaa00-8f23-11ea-9c50-b52dee452ee5.gif)

2. 메일 재전송 페이지 및 인증 페이지와 서버를 연결했습니다.

5/7 수정사항
------------------
1. 구글 로그인을 구현하여 로그인 폼에 추가하였습니다. 구현 과정에서 몇 가지 어려웠던 점들이 있었습니다.
    1. Django 서버 내부의 특정 view에서 다른 view로 리퀘스트를 전달하는 문제 - 구글 로그인을 수행했을 때 서버에 동일한 이메일을 가진 사용자가 존재한다면 그 사용자로 로그인시키고, 아니면 회원가입시키는 방식으로 구현했는데, 이를 위해서는 계정이 존재하는지 판정한 뒤 login view 또는 registration view로 request를 전달해야 했습니다. 이를 위해 새롭게 GoogleLoginAPI라는 view를 새로 만들고, /api/google URL과 연결했습니다. 또한 LoginAPI와 RegistrationAPI를 상속받게 하여 판정 후에 적절한 view에서 처리할 수 있도록 하였습니다.
      
    2. 구글 계정으로 로그인했을 때 로그아웃을 수행해도 다시 로그인이 되던 문제 - 기존에 구글에서 제공하는 gapi.auth2.render()를 통해 로그인 버튼을 만들면 로그인 버튼이 렌더링 될 때마다 구글 계정 로그인 여부를 체크하고, 구글계정이 로그인 되어 있는 경우 자동으로 로그인이 되던 문제가 발생했습니다. 이를 해결하기 위해 직접 custom button을 만들고, onClick 이벤트를 통해 렌더링 될 때가 아닌 버튼을 클릭했을 때 로그인 이벤트를 발생시키도록 했습니다. 버튼을 클릭하면 gapi.auth2.getAuthInstance()를 통해 사용자 계정 객체를 생성하고, gapi.auth2.signIn()을 통해 구글 서버에 로그인을 요청합니다. 이를 통해 googleUser 객체를 받아 이 객체의 메소드인 getAuthResponse를 통해 access token을 뽑아내고, /api/google로 POST 요청을 보내 서버에서 유효성을 판정한 뒤 사용자에 대한 정보를 이용할 수 있도록 구현했습니다.
2. 도커 서비스의 프로세스 유저가 root 대신 현재 사용자가 되도록 했습니다. 이를 위해, `docker-compose` 명령 대신 `./udco`를 사용해야 합니다.
   
5/8 수정사항
-----------------
 아이디/비밀번호 찾기에 사용할 API를 만들었습니다. api/forgot으로 POST 명령을 보내면 ID나 비밀번호를 찾을 수 있습니다. 형식은 다음과 같이 해주세요.
 {'IDorPassword' : 'id' 또는 'password', username : 사용자 닉네임(비밀번호 찾을 때만, ID 찾을땐 빈칸으로), email : 사용자 이메일}
 아이디 찾기는 response의 id필드에서 꺼내쓰면 되고, 비밀번호 찾기는 이메일주소로 임시 비밀번호가 적힌 메일이 발송됩니다. 해당 비밀번호로 로그인하여 
 추후에 비밀번호를 바꾸던가 하면 될것같습니다.

5/12 수정사항
-----------------
아이디/비밀번호 찾기 구현을 완료했습니다. 아래와 같은 문제점들이 발생했습니다.
1. 이메일 재전송이나 회원가입, 비밀번호 찾기 수행 시 서버에서 fetch할 동안 버튼이 눌리는 문제가 발생합니다. fetch하는 동안에는 버튼이 비활성화되게 하는    방안이 필요합니다. (로딩 스피너라던가)
2. 아이디 찾기를 수행할 때 간헐적으로 페이지가 다운되는 현상이 있습니다.

5/13 수정사항
-----------------
1. 버튼 로딩 스피너를 만들었습니다. 서버로 보낸 fetch 명령이 끝날 동안, 버튼은 로딩 상태가 되어 눌리지 않게 됩니다. fetch 명령이 끝나면 버튼은 다시 활성화 상태로 돌아갑니다.
2. 페이스북 로그인 연동을 완료했습니다. 구현 과정에서 GoogleAccount.txt의 내용이 바뀌었습니다.(카톡방에 다시 올려드릴게요)
   페이스북 연동 과정에서 아래와 같은 문제점들이 발생했습니다.
     1. 동명이인 문제 
         1-1. 한 사용자가 구글 로그인과 페이스북 로그인을 동시에 사용할 때, 이 사용자가 동일한 사용자라는 것을 어떻게 구별할 것인가?
         1-2. 이름이 같은 사용자가 로그인 할 때, 이 사람을 다른 동명이인들과 어떻게 구별할 것인가?
         -> 동명이인 사용자를 구별할 수 있는 방안이 필요함.
         
     2. 구글 로그인과 페이스북 로그인을 동시에 사용할 때, 비밀번호를 어떻게 알아내어 로그인을 해야할까?
        -> 기존 구글 로그인은 구글 API에서 보내주는 id를 비밀번호로 사용했기 때문에, 페이스북으로 로그인하는것이 불가능했습니다. User 모델에서 비밀번호를 알아내어 로그인하는 방법도 생각해봤지만,
           비밀번호가 암호화되어있어 django 내에서도 확인이 불가능합니다. 일단 모든 소셜 로그인의 비밀번호를 'social' 로 설정하여 임시로 문제를 해결했지만, 로그인 창에 이름과 social만 입력해도
           로그인이 가능해졌기 때문에 다른 방안이 필요할 것 같습니다. (비밀번호를 2개 저장한다던가, 새로운 비밀번호를 생성한다던가)

5/14 수정사항
----------------
1. 동명이인 문제를 해결했습니다. User 모델에 닉네임 필드가 새로 생겼으며, 소셜 로그인을 할 떄는 닉네임에 이름을, id에는 해당 소셜 서비스에서 제공하는 API에서 받아온 id값을 저장하게 됩니다. 
   비밀번호는 social로 통합시켰습니다. 일반 사용자는 15자 이상의 아이디를 만들 수 없으므로 소셜 로그인으로 만들어지는 아이디와 중복될 수 없게 됩니다(소셜 로그인 아이디는 15자보다 깁니다.).

2. 로그인 필드에 유효성 검사를 추가했습니다. 일반 로그인을 진행할 때는 아이디와 비밀번호의 글자 수를    8~15자로 제한하고, 영어, 숫자를 포함하도록 했습니다.

3. 소셜로그인을 했을 때 기존 가입 회원 중 동일한 이메일을 쓰는 회원이 있을 경우, 자동으로 계정이 연동되도록 수정했습니다. 회원 정보는 기존에 가입했던 계정 정보를 따라가게 됩니다.

  팀 구성 관련해서 아래와 같이 생각해볼 점들이 있었습니다.
  
    팀원을 초대할 때 
      - 닉네임으로 초대하게 할 것인가? -> 이 경우, 닉네임이 중복 가능하기 때문에 검색했을 때 해당 사용자의 이메일 주소와 함께 보여줘야 함.
      - 아이디로 초대하게 할 것인가? -> 이 경우, 소셜로그인으로 가입한 회원 추가가 힘들 수 있음. -> 각 사용자가 자신의 아이디를
                                   확인할 수 있도록 해야 함. 이를 팀장에게 알려줘서 팀장이 아이디를 통해 초대를 보낼 수 있게 하는 식으로 구현
                                   
5/15 수정사항
------------------
1. 팀 관련 API를 만들었습니다. API가 제공하는 기능은 아래와 같습니다.
   1. 새로운 팀을 생성하고, 전체 팀의 정보를 확인할 수 있습니다.
   2. 팀 id를 통해 해당 팀의 정보를 출력하고, 팀을 삭제할 수 있으며(팀장만), 팀 이름을 변경할 수 있습니다(팀장만).
   3. 새로운 팀원을 초대할 수 있습니다(팀장만). 추후에 팀원에게 초대권한을 주는 기능을 만드는 것도 좋을 것 같습니다. 각 사용자는 자신을 초대한 팀들의 이름을 확인할 수 있습니다. 아직 초대를 수락하여 팀에 들어가는 기능은 미구현 상태입니다.
   4. 각 팀원들은 공유폴더를 설정하고 해제할 수 있습니다. 미구현 상태이며 디렉토리 모델이 만들어지는 대로 구현할 예정입니다.
  
5/16 수정사항
------------------
1. 팀에 초대받은 사용자가 초대를 수락하는 기능 및 거절하는 기능을 추가했습니다.
2. 공유폴더 설정 및 해제 기능을 추가했습니다. 
   
5/18 수정사항
------------------
1. 썸네일 기능을 구현했습니다. 작동 로직은 아래와 같습니다.
   1. storage/views.py에서 파일 업로드를 마친 뒤, 해당 파일이 이미지 파일인지 확인합니다.
   2. 이미지 파일이 아니라면 그대로 나머지 업로드 로직을 진행하고, 맞다면 thumbnail.py의 MakeThumbnail 클래스를 이용하여 썸네일을 제작한 뒤, 
      해당 파일을 file/complete/사용자명/thumbnail/ 에 파일ID.jpg의 형태로 저장합니다(Nginx 상에서는 media/files/사용자명/thumbnail 디렉토리에 저장됩니다.).
   3. 썸네일이 저장된 경로를 업로드 response의 body에 thumbnail_url : {url} 형태로 실어서 response를 전송합니다.
   4. 해당 url로 접속하면 서버에 저장된 썸네일 아이콘이 보이게 됩니다. 이것을 이용해 리액트쪽에서 썸네일 이미지를 보여주면 됩니다.
   
   storage앱의 view.py에 있는 ThumbnailTestAPI와 thumbnail 앱은 테스트용으로, 제거할 예정입니다.
   썸네일 이미지 테스트 페이지는 localhost/thumb-test에 가시면 확인할 수 있으며, 사용자 아이디를 sungs201로 설정하셔야 합니다
   (이는 테스트용 설정으로, 추후에 업로드 구현이 완료되면 업로드한 계정으로 로그인 하시면 됩니다.).
   
URL 사용법
------------------
리액트 폼

|URL          | 설명   |
|:--------------:|:-------:|
|/|메인 페이지, 로그인한 사용자의 아이디를 확인할 수 있습니다.|
|/login|로그인 페이지, 로그인 성공 시 /login-test로 리다이렉트됩니다.|
|/signup|회원가입 페이지입니다.|
|/mail-resend|메일인증을 받지 않은 계정으로 로그인했을 때, 이 페이지로 이동합니다. 이 페이지에서 가입 시에 등록한 이메일을 확인할 수 있고, 인증 메일을 다시 전송받을 수 있습니다.|
|/mail-validation/*|등록한 이메일에 써있는 URL 통해 이동할 수 있는 메일 인증 관련 페이지입니다.|
|/forgot-id|아이디 찾기 페이지입니다. 메일 주소를 입력한 뒤 확인 버튼을 누르면 /display-id 페이지로 리다이렉트됩니다.|
|/display-id|아이디 찾기 결과를 보여주는 페이지입니다.|
|/forgot-password|비밀번호 찾기 페이지입니다. 아이디와 이메일 주소를 입력하면 이메일 주소로 임시 비밀번호를 받을 수 있습니다. /return-to-login 페이지로 리다이렉트됩니다.|
|/return-to-login|로그인 페이지로 돌아갈 수 있는 버튼이 있는 페이지입니다.|
|/thumb-test|썸네일 테스트 페이지로, 사용자 아이디가 sungs201인 계정으로 로그인한 뒤 접속해야 합니다(테스트용).|

API

127.0.0.1/api 뒤에 아래의 URL을 붙이면 됩니다.

사용자 계정 관련 API
---------------------
|           | POST    | GET        | DELETE  |
|:--------------:|:-------:|:--------------------------: |:-------:|
| /users | - | 전체 사용자 출력 |      -     |
| /user| - | 해당 회원의 정보 출력 | 해당 회원의 정보 제거 |
| /registration | 회원가입 |-|-|
| /jwt-login | 로그인 |-|-|
| /logout | 로그아웃 |-|-|
| /send-auth-email | 인증 메일 보내기 |-|-|
| /jwt-refresh | JWT 토큰 재발급|-|-|
| /jwt-verify | JWT 토큰 유효성 확인 |-|-|
| /active/<str:uidb64>/<str:token> |-| 인증메일에 사용하는 URL |-|

* GET /api/user와 DELETE /api/user를 통해서 사용자의 정보를 확인하거나, 삭제할 수 있습니다. 어떤 사용자인지는 클라이언트 브라우저에 저장되어 있는
  HttpOnly JWT 토큰 쿠키를 통해 서버에서 식별합니다. 

* POST /api/register 는 HTTP body에 json 형식으로 username, password, email 필드를 필수로 넘겨줘야 하며, phone_num 필드는 선택사항입니다.

* POST /api/jwt-login은 HTTP body에 json 형식으로 username, password를 넘겨줘야 하며, 서버는 response로 HttpOnly 속성을 지닌 쿠키에 JWT 토큰을 담아서 보내줍니다.
   한번 로그인했을 때 토큰의 유효시간은 30분입니다.

* POST /api/jwt-refresh는 HTTP body에 json 형식으로 token : <발급받은 토큰>을 넣어주면 유효 시간이 갱신된 새로운 토큰을 받을 수 있습니다.
  발급받은 토큰이 만료되면 새로운 토큰을 받을 수 없으니, 만료 되기 전에 이 URL을 통해 새로운 토큰을 발급받으면 됩니다(페이지에 버튼을 따로 만들거나 하면 될것같아요).
  
* POST /api/jwt-verify는 현재 클라이언트 브라우저에 저장되어 있는 HttpOnly 쿠키 안에 있는 jwt 토큰의 유효성을 확인합니다. 

* POST /api/logout을 통해 로그아웃을 수행할 수 있으며, 클라이언트 브라우저에서 JWT 토큰이 저장된 쿠키를 삭제합니다.
   
* /active/<str:uidb64>/<str:token>은 인증메일용 URL로, 이메일 인증에만 사용됩니다.

팀 관련 API
--------------------
|           | POST    | GET        | DELETE  | PUT |
|:--------------:|:-------:|:--------------------------: |:-------:|:------:|
| /team | 새로운 팀 생성 |전체 팀 정보 확인|-|-|
| /team/<팀 id>|-|팀 정보 출력(팀명, 팀장, 팀원목록, 공유폴더 목록)|팀 삭제(팀장만 가능)|팀 이름 변경|
| /team/<팀 id>/invitation|-|-|-|새로운 팀원 초대 (팀장만 가능)|
| /team/<팀 id>/acceptance|-|-|초대 거부|초대 수락|
| /team/<팀 id>/secession |-|-|-|팀에서 탈퇴|
| /team/<팀 id>/sharing | 공유폴더 설정 |-|공유폴더 해제|-|

* /team으로의 POST 요청을 통해 새로운 팀을 생성할 수 있으며, GET 요청을 통해 현재 생성되어 있는 전체 팀의 정보를 확인할 수 있습니다. POST요청의 body에는 teamName(팀 이름), teamLeader(팀 만든사람)이 포함되어야 합니다.

* /team/<팀 id>으로의 GET 요청을 통해 해당 팀의 정보를 확인할 수 있으며, DELETE 요청을 통해 해당 팀을 제거할 수 있습니다.

* /team/<팀 id>/invitation으로의 PUT 요청을 통해 새로운 사용자를 팀으로 들어오도록 초대할 수 있습니다. 초대받은 사용자는 아래의 /team/<팀 id>/acceptance URL을 통하여 초대를 수락하거나 거부할 수 있습니다.

* /team/<팀 id>/acceptance으로의 PUT 요청을 통해 초대를 수락할 수 있으며, DELETE 요청을 통해 초대를 거부할 수 있습니다.

* /team/<팀 id>/secession으로의 PUT 요청을 통해 소속된 팀에서 탈퇴할 수 있습니다.

* /team/<팀 id>/sharing으로의  POST 요청을 통해 공유폴더를 설정할 수 있으며, DELETE 요청을 통해 설정된 공유폴더를 해제할 수 있습니다. POST 요청 body에는 공유 폴더로 설정할 디렉토리의 ID가 포함되어야 합니다.


사용예
------------------
1. 전체 유저 목록 출력
![1  전체 유저 목록 출력](https://user-images.githubusercontent.com/49271247/79839313-4f5ae200-83ef-11ea-99c1-f62e9c794d90.png)

2. 회원가입
![2  회원 가입](https://user-images.githubusercontent.com/49271247/79839454-7e715380-83ef-11ea-960f-f6f6b253f71d.png)

3. 메일 인증 하지 않고 로그인 시도할 때
![3  메일 인증 미수행](https://user-images.githubusercontent.com/49271247/79839458-803b1700-83ef-11ea-95b4-e2621776ed8f.png)

4. 인증 메일
![4  인증 메일](https://user-images.githubusercontent.com/49271247/79839460-80d3ad80-83ef-11ea-80e3-db72271c51e4.png)

5. 메일에 있는 URL을 통한 계정 활성화
![5  메일 활성화](https://user-images.githubusercontent.com/49271247/79839461-80d3ad80-83ef-11ea-88d7-b6b76a149746.png)

6. 로그인 성공
![6  로그인 성공](https://user-images.githubusercontent.com/49271247/79839464-816c4400-83ef-11ea-887c-9c60394b3556.png)

7. 프로필 보기
![프로필 보기](https://user-images.githubusercontent.com/49271247/79839466-8204da80-83ef-11ea-8699-96fc944bd702.png)

8. 회원 탈퇴
![회원 탈퇴](https://user-images.githubusercontent.com/49271247/79839467-8204da80-83ef-11ea-8607-150b67794d55.png)


